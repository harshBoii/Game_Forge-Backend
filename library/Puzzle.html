
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Puzzle / Matching - Phaser Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html,body { margin:0; padding:0; background:#111; height:100%; }
    .hint { position: absolute; right: 12px; top: 12px; color:#ddd; font-family: monospace; font-size:13px; background: rgba(0,0,0,0.25); padding:8px; border-radius:6px; z-index: 1000;}
  </style>
</head>
<body>
  <div class="hint">Click tiles to select, then click adjacent tile to swap</div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>

  <!-- REGION:SCENE_CLASS_START -->
  <script>
  class PuzzleScene extends Phaser.Scene {
    constructor() { super('PuzzleScene'); }
    
    preload() {}
    
    create() {
      this.tileSize = 64;
      this.cols = 8;
      this.rows = 8;
      this.offsetX = 100;
      this.offsetY = 100;
      this.colors = [0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff];
      this.grid = [];
      this.selected = null;
      this.isProcessing = false;

      this.createGrid();
      this.input.on('pointerdown', this.handlePointer, this);

      this.score = 0;
      this.moves = 0;
      this.createUI();
      
      // Initial check for matches
      this.time.delayedCall(100, () => this.checkAndRemoveMatches());
    }

    update() {}

    createGrid() {
      for (let y = 0; y < this.rows; y++) {
        this.grid[y] = [];
        for (let x = 0; x < this.cols; x++) {
          this.grid[y][x] = this.createTile(x, y);
        }
      }
    }

    createTile(x, y) {
      const color = Phaser.Utils.Array.GetRandom(this.colors);
      const tile = this.add.rectangle(
        this.offsetX + x * this.tileSize,
        this.offsetY + y * this.tileSize,
        this.tileSize - 4,
        this.tileSize - 4,
        color
      ).setInteractive();
      
      tile.colorValue = color;
      tile.gridX = x;
      tile.gridY = y;
      
      return tile;
    }

    handlePointer(pointer) {
      if (this.isProcessing) return;
      
      const x = Math.floor((pointer.x - this.offsetX) / this.tileSize);
      const y = Math.floor((pointer.y - this.offsetY) / this.tileSize);
      
      if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) return;

      const tile = this.grid[y][x];
      if (!tile) return;

      if (!this.selected) {
        this.selected = tile;
        tile.setStrokeStyle(4, 0xffffff);
      } else {
        if (this.areAdjacent(this.selected, tile)) {
          this.selected.setStrokeStyle(0);
          this.swapTiles(this.selected, tile);
        } else {
          this.selected.setStrokeStyle(0);
          this.selected = tile;
          tile.setStrokeStyle(4, 0xffffff);
        }
      }
    }

    areAdjacent(a, b) {
      const dx = Math.abs(a.gridX - b.gridX);
      const dy = Math.abs(a.gridY - b.gridY);
      return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
    }

    swapTiles(tileA, tileB) {
      this.isProcessing = true;
      
      // Store original grid positions
      const ax = tileA.gridX;
      const ay = tileA.gridY;
      const bx = tileB.gridX;
      const by = tileB.gridY;
      
      // Swap grid positions
      tileA.gridX = bx;
      tileA.gridY = by;
      tileB.gridX = ax;
      tileB.gridY = ay;
      
      // Update grid array using ORIGINAL positions
      this.grid[ay][ax] = tileB;
      this.grid[by][bx] = tileA;
      
      // Animate swap
      this.tweens.add({
        targets: tileA,
        x: this.offsetX + bx * this.tileSize,
        y: this.offsetY + by * this.tileSize,
        duration: 250,
        ease: 'Cubic.easeOut'
      });
      
      this.tweens.add({
        targets: tileB,
        x: this.offsetX + ax * this.tileSize,
        y: this.offsetY + ay * this.tileSize,
        duration: 250,
        ease: 'Cubic.easeOut',
        onComplete: () => {
          const matches = this.findMatches();
          if (matches.length === 0) {
            // No matches - swap back
            this.swapBack(tileA, tileB);
          } else {
            // Valid move
            this.moves++;
            this.movesText.setText('Moves: ' + this.moves);
            this.selected = null;
            this.checkAndRemoveMatches();
          }
        }
      });
    }

    swapBack(tileA, tileB) {
      // Swap back grid positions
      const tempX = tileA.gridX;
      const tempY = tileA.gridY;
      tileA.gridX = tileB.gridX;
      tileA.gridY = tileB.gridY;
      tileB.gridX = tempX;
      tileB.gridY = tempY;
      
      // Update grid
      this.grid[tileA.gridY][tileA.gridX] = tileA;
      this.grid[tileB.gridY][tileB.gridX] = tileB;
      
      // Animate back
      this.tweens.add({
        targets: tileA,
        x: this.offsetX + tileA.gridX * this.tileSize,
        y: this.offsetY + tileA.gridY * this.tileSize,
        duration: 250,
        ease: 'Cubic.easeOut'
      });
      
      this.tweens.add({
        targets: tileB,
        x: this.offsetX + tileB.gridX * this.tileSize,
        y: this.offsetY + tileB.gridY * this.tileSize,
        duration: 250,
        ease: 'Cubic.easeOut',
        onComplete: () => {
          this.selected = null;
          this.isProcessing = false;
        }
      });
    }

    findMatches() {
      let matches = new Set();
      
      // Check horizontal matches
      for (let y = 0; y < this.rows; y++) {
        for (let x = 0; x < this.cols - 2; x++) {
          const t1 = this.grid[y][x];
          const t2 = this.grid[y][x + 1];
          const t3 = this.grid[y][x + 2];
          
          if (t1 && t2 && t3 && 
              t1.colorValue === t2.colorValue && 
              t2.colorValue === t3.colorValue) {
            matches.add(t1);
            matches.add(t2);
            matches.add(t3);
          }
        }
      }
      
      // Check vertical matches
      for (let x = 0; x < this.cols; x++) {
        for (let y = 0; y < this.rows - 2; y++) {
          const t1 = this.grid[y][x];
          const t2 = this.grid[y + 1][x];
          const t3 = this.grid[y + 2][x];
          
          if (t1 && t2 && t3 && 
              t1.colorValue === t2.colorValue && 
              t2.colorValue === t3.colorValue) {
            matches.add(t1);
            matches.add(t2);
            matches.add(t3);
          }
        }
      }
      
      return Array.from(matches);
    }

    checkAndRemoveMatches() {
      const matches = this.findMatches();
      
      if (matches.length > 0) {
        this.removeTiles(matches);
      } else {
        this.isProcessing = false;
      }
    }

    removeTiles(matches) {
      // Update score
      this.score += matches.length * 10;
      this.scoreText.setText('Score: ' + this.score);
      
      // Animate and remove tiles
      matches.forEach(tile => {
        this.tweens.add({
          targets: tile,
          alpha: 0,
          scale: 0,
          duration: 200,
          onComplete: () => {
            tile.destroy();
            this.grid[tile.gridY][tile.gridX] = null;
          }
        });
      });
      
      // Wait for removal animation then drop tiles
      this.time.delayedCall(250, () => this.dropTiles());
    }

    dropTiles() {
      let hasMoved = false;
      
      // Drop tiles from bottom to top
      for (let x = 0; x < this.cols; x++) {
        let emptySpaces = 0;
        
        for (let y = this.rows - 1; y >= 0; y--) {
          if (this.grid[y][x] === null) {
            emptySpaces++;
          } else if (emptySpaces > 0) {
            // Move tile down
            const tile = this.grid[y][x];
            const newY = y + emptySpaces;
            
            this.grid[y][x] = null;
            this.grid[newY][x] = tile;
            tile.gridY = newY;
            
            this.tweens.add({
              targets: tile,
              y: this.offsetY + newY * this.tileSize,
              duration: 300,
              ease: 'Bounce.easeOut'
            });
            
            hasMoved = true;
          }
        }
        
        // Fill empty spaces at top
        for (let y = 0; y < this.rows; y++) {
          if (this.grid[y][x] === null) {
            const newTile = this.createTile(x, y);
            newTile.setAlpha(0);
            newTile.y = this.offsetY - this.tileSize;
            this.grid[y][x] = newTile;
            
            this.tweens.add({
              targets: newTile,
              y: this.offsetY + y * this.tileSize,
              alpha: 1,
              duration: 300,
              ease: 'Bounce.easeOut'
            });
            
            hasMoved = true;
          }
        }
      }
      
      // Check for new matches after drop
      if (hasMoved) {
        this.time.delayedCall(350, () => this.checkAndRemoveMatches());
      } else {
        this.isProcessing = false;
      }
    }

    createUI() {
      this.add.text(20, 20, 'Match 3 Puzzle', { 
        fontFamily: 'monospace', 
        fontSize: 24, 
        color: '#fff',
        fontStyle: 'bold'
      });
      
      this.scoreText = this.add.text(20, 55, 'Score: 0', { 
        fontFamily: 'monospace', 
        fontSize: 18, 
        color: '#55ff55'
      });
      
      this.movesText = this.add.text(20, 80, 'Moves: 0', { 
        fontFamily: 'monospace', 
        fontSize: 18, 
        color: '#5555ff'
      });
      
      const resetBtn = this.add.text(520, 20, 'Reset', {
        fontFamily: 'monospace',
        fontSize: 18,
        color: '#fff',
        backgroundColor: '#444',
        padding: { x: 12, y: 6 }
      }).setInteractive();
      
      resetBtn.on('pointerdown', () => this.scene.restart());
      resetBtn.on('pointerover', () => resetBtn.setStyle({ backgroundColor: '#666' }));
      resetBtn.on('pointerout', () => resetBtn.setStyle({ backgroundColor: '#444' }));
    }
  }
  </script>
  <!-- REGION:SCENE_CLASS_END -->

  <!-- REGION:CONFIG_START -->
  <script>
  const config = {
    type: Phaser.AUTO,
    width: 600,
    height: 700,
    backgroundColor: 0x1e1e2a,
    scene: [PuzzleScene]
  };
  </script>
  <!-- REGION:CONFIG_END -->

  <!-- REGION:GAME_INIT_START -->
  <script>
  window.onload = () => {
    const game = new Phaser.Game(config);
  };
  </script>
  <!-- REGION:GAME_INIT_END -->

</body>
</html>