<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Match 3 Puzzle - Vanilla Canvas</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #1e1e2a;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
        }
        
        #gameContainer {
            position: relative;
            width: 600px;
            height: 700px;
            background: #111;
            border: 2px solid #444;
        }
        
        canvas {
            display: block;
            background: #1e1e2a;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
        }
        
        #title {
            font-size: 24px;
            font-weight: bold;
            color: #55ff55;
            margin-bottom: 10px;
        }
        
        #score, #moves {
            color: #55ff55;
            margin: 5px 0;
        }
        
        #moves {
            color: #5555ff;
        }
        
        #resetBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 16px;
            transition: all 0.2s;
        }
        
        #resetBtn:hover {
            background: #666;
            border-color: #888;
        }
        
        #resetBtn:active {
            background: #333;
        }
        
        .hint {
            position: absolute;
            right: 20px;
            bottom: 20px;
            color: #aaa;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
            max-width: 200px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="600" height="700"></canvas>
        
        <div id="ui">
            <div id="title">Match 3 Puzzle</div>
            <div id="score">Score: 0</div>
            <div id="moves">Moves: 0</div>
        </div>
        
        <button id="resetBtn">Reset</button>
        <div class="hint">Click tiles to select, click adjacent tile to swap</div>
    </div>

    <script>
        // =====================================================
        // CANVAS SETUP
        // =====================================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        console.log('âœ… Match 3 Game Canvas initialized');

        // =====================================================
        // GAME STATE (âœ… MODIFY THESE VALUES)
        // =====================================================
        const game = {
            tileSize: 64,
            cols: 8,
            rows: 8,
            offsetX: 50,
            offsetY: 120,
            
            colors: [
                '#ff5555',  // Red
                '#55ff55',  // Green
                '#5555ff',  // Blue
                '#ffff55',  // Yellow
                '#ff55ff'   // Magenta
            ],
            
            grid: [],
            selected: null,
            isProcessing: false,
            
            score: 0,
            moves: 0,
            
            animatingTiles: new Map()
        };

        // =====================================================
        // TILE OBJECT
        // =====================================================
        class Tile {
            constructor(x, y, color) {
                this.gridX = x;
                this.gridY = y;
                this.color = color;
                this.x = game.offsetX + x * game.tileSize + game.tileSize / 2;
                this.y = game.offsetY + y * game.tileSize + game.tileSize / 2;
                this.scale = 1;
                this.alpha = 1;
                this.isAnimating = false;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(
                    this.x - (game.tileSize - 4) / 2 * this.scale + 2,
                    this.y - (game.tileSize - 4) / 2 * this.scale + 2,
                    (game.tileSize - 4) * this.scale,
                    (game.tileSize - 4) * this.scale
                );
                
                // Draw tile
                ctx.fillStyle = this.color;
                ctx.fillRect(
                    this.x - (game.tileSize - 4) / 2 * this.scale,
                    this.y - (game.tileSize - 4) / 2 * this.scale,
                    (game.tileSize - 4) * this.scale,
                    (game.tileSize - 4) * this.scale
                );
                
                // Draw border if selected
                if (this === game.selected) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        this.x - (game.tileSize - 4) / 2 * this.scale,
                        this.y - (game.tileSize - 4) / 2 * this.scale,
                        (game.tileSize - 4) * this.scale,
                        (game.tileSize - 4) * this.scale
                    );
                }
                
                ctx.restore();
            }
        }

        // =====================================================
        // GAME FUNCTIONS
        // =====================================================
        function createGrid() {
            game.grid = [];
            for (let y = 0; y < game.rows; y++) {
                game.grid[y] = [];
                for (let x = 0; x < game.cols; x++) {
                    const color = game.colors[Math.floor(Math.random() * game.colors.length)];
                    game.grid[y][x] = new Tile(x, y, color);
                }
            }
            
            // Remove initial matches
            removeInitialMatches();
        }

        function removeInitialMatches() {
            let matches;
            while ((matches = findMatches()).length > 0) {
                matches.forEach(tile => {
                    const color = game.colors[Math.floor(Math.random() * game.colors.length)];
                    tile.color = color;
                });
            }
        }

        function handleCanvasClick(e) {
            if (game.isProcessing) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const x = Math.floor((mouseX - game.offsetX) / game.tileSize);
            const y = Math.floor((mouseY - game.offsetY) / game.tileSize);
            
            if (x < 0 || y < 0 || x >= game.cols || y >= game.rows) return;
            
            const tile = game.grid[y][x];
            if (!tile) return;
            
            if (!game.selected) {
                game.selected = tile;
                console.log('Selected tile at', x, y);
            } else {
                if (areAdjacent(game.selected, tile)) {
                    swapTiles(game.selected, tile);
                } else {
                    game.selected = tile;
                    console.log('New selection at', x, y);
                }
            }
        }

        function areAdjacent(a, b) {
            const dx = Math.abs(a.gridX - b.gridX);
            const dy = Math.abs(a.gridY - b.gridY);
            return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
        }

        function swapTiles(tileA, tileB) {
            game.isProcessing = true;
            
            const ax = tileA.gridX;
            const ay = tileA.gridY;
            const bx = tileB.gridX;
            const by = tileB.gridY;
            
            // Swap in grid
            game.grid[ay][ax] = tileB;
            game.grid[by][bx] = tileA;
            
            // Swap grid positions
            tileA.gridX = bx;
            tileA.gridY = by;
            tileB.gridX = ax;
            tileB.gridY = ay;
            
            // Animate swap
            animateTile(tileA, tileA.x, tileA.y, game.offsetX + bx * game.tileSize + game.tileSize / 2, game.offsetY + by * game.tileSize + game.tileSize / 2, 250);
            
            setTimeout(() => {
                animateTile(tileB, tileB.x, tileB.y, game.offsetX + ax * game.tileSize + game.tileSize / 2, game.offsetY + ay * game.tileSize + game.tileSize / 2, 250);
            }, 125);
            
            setTimeout(() => {
                const matches = findMatches();
                if (matches.length === 0) {
                    // Swap back
                    game.grid[ay][ax] = tileA;
                    game.grid[by][bx] = tileB;
                    
                    tileA.gridX = ax;
                    tileA.gridY = ay;
                    tileB.gridX = bx;
                    tileB.gridY = by;
                    
                    animateTile(tileA, tileA.x, tileA.y, game.offsetX + ax * game.tileSize + game.tileSize / 2, game.offsetY + ay * game.tileSize + game.tileSize / 2, 250);
                    
                    setTimeout(() => {
                        animateTile(tileB, tileB.x, tileB.y, game.offsetX + bx * game.tileSize + game.tileSize / 2, game.offsetY + by * game.tileSize + game.tileSize / 2, 250);
                    }, 125);
                    
                    setTimeout(() => {
                        game.selected = null;
                        game.isProcessing = false;
                    }, 400);
                } else {
                    game.moves++;
                    document.getElementById('moves').textContent = 'Moves: ' + game.moves;
                    game.selected = null;
                    removeTiles(matches);
                }
            }, 400);
        }

        function findMatches() {
            const matches = new Set();
            
            // Horizontal matches
            for (let y = 0; y < game.rows; y++) {
                for (let x = 0; x < game.cols - 2; x++) {
                    const t1 = game.grid[y][x];
                    const t2 = game.grid[y][x + 1];
                    const t3 = game.grid[y][x + 2];
                    
                    if (t1 && t2 && t3 && t1.color === t2.color && t2.color === t3.color) {
                        matches.add(t1);
                        matches.add(t2);
                        matches.add(t3);
                    }
                }
            }
            
            // Vertical matches
            for (let x = 0; x < game.cols; x++) {
                for (let y = 0; y < game.rows - 2; y++) {
                    const t1 = game.grid[y][x];
                    const t2 = game.grid[y + 1][x];
                    const t3 = game.grid[y + 2][x];
                    
                    if (t1 && t2 && t3 && t1.color === t2.color && t2.color === t3.color) {
                        matches.add(t1);
                        matches.add(t2);
                        matches.add(t3);
                    }
                }
            }
            
            return Array.from(matches);
        }

        function removeTiles(matches) {
            game.score += matches.length * 10;
            document.getElementById('score').textContent = 'Score: ' + game.score;
            
            // Animate removal
            let completed = 0;
            matches.forEach(tile => {
                animateTile(tile, tile.x, tile.y, tile.x, tile.y, 200, () => {
                    tile.alpha = 0;
                    tile.scale = 0;
                    game.grid[tile.gridY][tile.gridX] = null;
                    completed++;
                    
                    if (completed === matches.length) {
                        setTimeout(dropTiles, 100);
                    }
                });
            });
        }

        function dropTiles() {
            let hasMoved = false;
            
            for (let x = 0; x < game.cols; x++) {
                let emptySpaces = 0;
                
                // Count empty spaces and move tiles down
                for (let y = game.rows - 1; y >= 0; y--) {
                    if (game.grid[y][x] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        const tile = game.grid[y][x];
                        const newY = y + emptySpaces;
                        
                        game.grid[y][x] = null;
                        game.grid[newY][x] = tile;
                        
                        tile.gridY = newY;
                        
                        animateTile(tile, tile.x, tile.y, game.offsetX + x * game.tileSize + game.tileSize / 2, game.offsetY + newY * game.tileSize + game.tileSize / 2, 300);
                        hasMoved = true;
                    }
                }
                
                // Fill empty spaces at top
                for (let y = 0; y < game.rows; y++) {
                    if (game.grid[y][x] === null) {
                        const color = game.colors[Math.floor(Math.random() * game.colors.length)];
                        const newTile = new Tile(x, y, color);
                        newTile.y = game.offsetY - game.tileSize;
                        newTile.alpha = 0;
                        game.grid[y][x] = newTile;
                        
                        animateTile(newTile, newTile.x, newTile.y, game.offsetX + x * game.tileSize + game.tileSize / 2, game.offsetY + y * game.tileSize + game.tileSize / 2, 300, () => {
                            newTile.alpha = 1;
                        });
                        hasMoved = true;
                    }
                }
            }
            
            if (hasMoved) {
                setTimeout(() => checkForMatches(), 350);
            } else {
                game.isProcessing = false;
            }
        }

        function checkForMatches() {
            const matches = findMatches();
            if (matches.length > 0) {
                removeTiles(matches);
            } else {
                game.isProcessing = false;
            }
        }

        function animateTile(tile, fromX, fromY, toX, toY, duration, onComplete) {
            const startTime = Date.now();
            const update = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                tile.x = fromX + (toX - fromX) * progress;
                tile.y = fromY + (toY - fromY) * progress;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                } else {
                    tile.x = toX;
                    tile.y = toY;
                    if (onComplete) onComplete();
                }
            };
            update();
        }

        // =====================================================
        // RENDERING
        // =====================================================
        function draw() {
            ctx.fillStyle = '#1e1e2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid background
            ctx.fillStyle = '#111';
            ctx.fillRect(
                game.offsetX - 5,
                game.offsetY - 5,
                game.cols * game.tileSize + 10,
                game.rows * game.tileSize + 10
            );
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let x = 0; x <= game.cols; x++) {
                ctx.beginPath();
                ctx.moveTo(game.offsetX + x * game.tileSize, game.offsetY);
                ctx.lineTo(game.offsetX + x * game.tileSize, game.offsetY + game.rows * game.tileSize);
                ctx.stroke();
            }
            for (let y = 0; y <= game.rows; y++) {
                ctx.beginPath();
                ctx.moveTo(game.offsetX, game.offsetY + y * game.tileSize);
                ctx.lineTo(game.offsetX + game.cols * game.tileSize, game.offsetY + y * game.tileSize);
                ctx.stroke();
            }
            
            // Draw tiles
            for (let y = 0; y < game.rows; y++) {
                for (let x = 0; x < game.cols; x++) {
                    const tile = game.grid[y][x];
                    if (tile) {
                        tile.draw();
                    }
                }
            }
        }

        // =====================================================
        // GAME LOOP
        // =====================================================
        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        // =====================================================
        // EVENT LISTENERS
        // =====================================================
        canvas.addEventListener('click', handleCanvasClick);
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            game.score = 0;
            game.moves = 0;
            game.selected = null;
            game.isProcessing = false;
            document.getElementById('score').textContent = 'Score: 0';
            document.getElementById('moves').textContent = 'Moves: 0';
            createGrid();
        });

        // =====================================================
        // INIT
        // =====================================================
        createGrid();
        console.log('ðŸŽ® Match 3 Game Started!');
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
