<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Space Shooter - Vanilla Canvas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      background: radial-gradient(ellipse at center, #0a1a3a 0%, #000 100%);
      border-radius: 12px;
      box-shadow:
        0 0 80px rgba(0, 200, 255, 0.4),
        inset 0 0 50px rgba(0, 0, 0, 0.7);
      overflow: hidden;
    }

    canvas {
      display: block;
      background: linear-gradient(180deg, #000814 0%, #000 100%);
    }

    .ui-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #00ff00;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: rgba(0, 0, 0, 0.4);
      padding: 12px;
      border: 2px solid #00ff00;
      border-radius: 4px;
    }

    .ui-item {
      display: flex;
      gap: 8px;
    }

    .hint {
      position: absolute;
      right: 12px;
      top: 12px;
      color: #888;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid rgba(0, 200, 255, 0.2);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
      z-index: 10;
    }

    .game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      cursor: pointer;
      backdrop-filter: blur(4px);
    }

    .game-over-text {
      font-size: 64px;
      font-weight: bold;
      text-shadow: 0 0 20px;
      margin-bottom: 30px;
      animation: pulse 1s infinite;
    }

    .victory {
      color: #00ff00;
      text-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    }

    .defeat {
      color: #ff4444;
      text-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
    }

    .game-stats {
      color: #00ff00;
      font-size: 20px;
      text-align: center;
      line-height: 2;
      margin-bottom: 30px;
    }

    .restart-hint {
      color: #888;
      font-size: 14px;
      margin-top: 20px;
      animation: blink 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes blink {
      0%, 50%, 100% { opacity: 1; }
      25%, 75% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">
      <div class="ui-item">Score: <span id="score">0</span></div>
      <div class="ui-item">Lives: <span id="lives">3</span></div>
    </div>
    <div class="hint">← → to move • SPACE to shoot</div>
  </div>

  <script>
    // ============================================
    // CANVAS SETUP
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const maxWidth = Math.min(800, window.innerWidth - 20);
      const maxHeight = Math.min(600, window.innerHeight - 20);
      canvas.width = maxWidth;
      canvas.height = maxHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ============================================
    // GAME STATE (✅ EASY TO MODIFY)
    // ============================================
    const game = {
      // Player ship (✅ Adjust player stats)
      player: {
        x: 0,
        y: 0,
        width: 40,
        height: 40,
        velX: 0,
        speed: 4,             // ✅ Movement speed
        fireRate: 250,        // ✅ Milliseconds between shots
        lastFired: 0,
        color: '#00aaff'      // ✅ Ship color
      },

      // Bullets (✅ Adjust bullet behavior)
      bullets: [],
      bulletConfig: {
        width: 8,
        height: 8,
        speed: 7,             // ✅ Bullet speed
        color: '#ffff66'      // ✅ Bullet color
      },

      // Enemies (✅ Adjust enemy formation & difficulty)
      enemies: [],
      enemyConfig: {
        rows: 3,              // ✅ Number of rows
        cols: 8,              // ✅ Number of columns
        width: 32,
        height: 24,
        startX: 80,
        startY: 40,
        spacing: 80,          // ✅ Space between enemies
        speed: 1,             // ✅ Horizontal speed
        dropDistance: 30,     // ✅ Distance to drop when turning
        color: '#ff4444'      // ✅ Enemy color
      },

      // Enemy state
      enemyDirection: 1,      // 1 = right, -1 = left
      enemySpeed: 0,

      // Game state
      score: 0,
      lives: 3,
      gameRunning: true,
      gameOver: false,
      gameWon: false,

      // Input
      keys: {},

      // Particles
      particles: [],

      // Physics
      gravity: 0
    };

    // Initialize player
    game.player.x = canvas.width / 2 - game.player.width / 2;
    game.player.y = canvas.height - 80;

    // Create enemy grid
    function createEnemies() {
      game.enemies = [];
      const { rows, cols, width, height, startX, startY, spacing } = game.enemyConfig;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          game.enemies.push({
            x: startX + col * spacing,
            y: startY + row * spacing,
            width: width,
            height: height,
            active: true,
            color: game.enemyConfig.color
          });
        }
      }

      game.enemySpeed = game.enemyConfig.speed * game.enemyDirection;
    }

    createEnemies();

    // ============================================
    // PARTICLES (Visual effects)
    // ============================================
    function createExplosion(x, y, count = 12) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 2 + Math.random() * 3;
        game.particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          color: '#ff8800',
          size: 3 + Math.random() * 3
        });
      }
    }

    function updateParticles() {
      game.particles.forEach((p, idx) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1; // slight gravity
        p.life -= 0.02;

        if (p.life <= 0 || p.y > canvas.height) {
          game.particles.splice(idx, 1);
        }
      });
    }

    function drawParticles() {
      game.particles.forEach(p => {
        ctx.fillStyle = p.color.replace(')', `, ${p.life * 0.7})`).replace('#ff8800', 'rgba(255, 136, 0');
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(0.5, p.size), 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    document.addEventListener('keydown', (e) => {
      game.keys[e.key] = true;

      if (e.key === ' ' || e.code === 'Space') {
        e.preventDefault();
        shoot();
      }
    });

    document.addEventListener('keyup', (e) => {
      game.keys[e.key] = false;
    });

    // ============================================
    // PLAYER LOGIC
    // ============================================
    function updatePlayer() {
      if (!game.gameRunning) return;

      const p = game.player;

      // Movement (✅ Easy to control)
      if (game.keys['ArrowLeft'] || game.keys['a'] || game.keys['A']) {
        p.velX = -p.speed;
      } else if (game.keys['ArrowRight'] || game.keys['d'] || game.keys['D']) {
        p.velX = p.speed;
      } else {
        p.velX = 0;
      }

      // Apply velocity
      p.x += p.velX;

      // Clamp to world bounds
      p.x = Math.max(0, Math.min(p.x, canvas.width - p.width));
    }

    function shoot() {
      const now = Date.now();
      if (now - game.player.lastFired < game.player.fireRate) return;

      game.player.lastFired = now;

      game.bullets.push({
        x: game.player.x + game.player.width / 2 - 4,
        y: game.player.y,
        width: game.bulletConfig.width,
        height: game.bulletConfig.height,
        active: true,
        color: game.bulletConfig.color
      });
    }

    // ============================================
    // BULLET LOGIC
    // ============================================
    function updateBullets() {
      game.bullets.forEach((b, idx) => {
        b.y -= game.bulletConfig.speed;

        // Remove off-screen bullets
        if (b.y < -20) {
          game.bullets.splice(idx, 1);
        }
      });
    }

    // ============================================
    // ENEMY LOGIC
    // ============================================
    function updateEnemies() {
      if (game.enemies.filter(e => e.active).length === 0) {
        endGame(true); // Win
        return;
      }

      let shouldTurn = false;
      const speed = game.enemyConfig.speed;

      // Update enemy positions
      game.enemies.forEach(enemy => {
        if (!enemy.active) return;

        enemy.x += game.enemyDirection * speed;

        // Check if should turn
        if ((enemy.x >= canvas.width - 40 && game.enemyDirection > 0) ||
            (enemy.x <= 10 && game.enemyDirection < 0)) {
          shouldTurn = true;
        }
      });

      // Turn and drop (✅ Easy to adjust behavior)
      if (shouldTurn) {
        game.enemyDirection *= -1;
        game.enemies.forEach(enemy => {
          if (enemy.active) {
            enemy.y += game.enemyConfig.dropDistance;

            // Check if enemies reached player
            if (enemy.y > game.player.y - 40) {
              endGame(false); // Lose
            }
          }
        });
      }
    }

    // ============================================
    // COLLISION DETECTION
    // ============================================
    function checkCollisions() {
      // Bullets vs Enemies
      game.bullets.forEach((b, bIdx) => {
        game.enemies.forEach((e, eIdx) => {
          if (!e.active) return;

          if (
            b.x < e.x + e.width &&
            b.x + b.width > e.x &&
            b.y < e.y + e.height &&
            b.y + b.height > e.y
          ) {
            // Hit!
            game.bullets.splice(bIdx, 1);
            e.active = false;
            game.score += 10;
            createExplosion(e.x + e.width / 2, e.y + e.height / 2);
          }
        });
      });

      // Enemies vs Player
      game.enemies.forEach(e => {
        if (!e.active) return;

        if (
          game.player.x < e.x + e.width &&
          game.player.x + game.player.width > e.x &&
          game.player.y < e.y + e.height &&
          game.player.y + game.player.height > e.y
        ) {
          // Hit player
          e.active = false;
          game.lives -= 1;

          if (game.lives <= 0) {
            endGame(false); // Lose
          }
        }
      });
    }

    // ============================================
    // RENDERING
    // ============================================
    function drawBackground() {
      // Starfield background
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#000814');
      grad.addColorStop(1, '#000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.fillStyle = 'rgba(100, 150, 200, 0.4)';
      for (let i = 0; i < 50; i++) {
        const x = (i * 123 + Date.now() * 0.01) % canvas.width;
        const y = (i * 76) % canvas.height;
        const size = (i % 3) * 0.5 + 0.5;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawPlayer() {
      const p = game.player;
      ctx.save();
      ctx.translate(p.x + p.width / 2, p.y + p.height / 2);

      // Glow
      ctx.fillStyle = 'rgba(0, 170, 255, 0.2)';
      ctx.beginPath();
      ctx.arc(0, 0, p.width + 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.translate(-p.width / 2, -p.height / 2);

      // Ship body (triangle pointing up)
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.moveTo(p.width / 2, 0);
      ctx.lineTo(p.width, p.height);
      ctx.lineTo(0, p.height);
      ctx.closePath();
      ctx.fill();

      // Ship outline
      ctx.strokeStyle = '#0066aa';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Cockpit
      ctx.fillStyle = '#ffff99';
      ctx.beginPath();
      ctx.arc(p.width / 2, p.height / 3, 3, 0, Math.PI * 2);
      ctx.fill();

      // Engine glow
      ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
      ctx.fillRect(p.width / 2 - 4, p.height - 5, 8, 6);

      ctx.restore();
    }

    function drawBullets() {
      game.bullets.forEach(b => {
        // Glow
        ctx.fillStyle = 'rgba(255, 255, 102, 0.4)';
        ctx.beginPath();
        ctx.arc(b.x + b.width / 2, b.y + b.height / 2, b.width + 4, 0, Math.PI * 2);
        ctx.fill();

        // Bullet
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.width, b.height);

        // Trail
        ctx.strokeStyle = 'rgba(255, 255, 102, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(b.x + b.width / 2, b.y + b.height);
        ctx.lineTo(b.x + b.width / 2, b.y + b.height + 8);
        ctx.stroke();
      });
    }

    function drawEnemies() {
      game.enemies.forEach(e => {
        if (!e.active) return;

        ctx.save();
        ctx.translate(e.x, e.y);

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(2, e.height + 2, e.width - 4, 3);

        // Enemy body
        ctx.fillStyle = e.color;
        ctx.fillRect(0, 0, e.width, e.height);

        // Enemy eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(6, 6, 6, 8);
        ctx.fillRect(e.width - 12, 6, 6, 8);

        // Enemy pupils
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(8, 8, 2, 4);
        ctx.fillRect(e.width - 10, 8, 2, 4);

        // Enemy outline
        ctx.strokeStyle = '#aa2222';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, e.width, e.height);

        ctx.restore();
      });
    }

    // ============================================
    // UI & GAME STATE
    // ============================================
    function updateUI() {
      document.getElementById('score').textContent = game.score;
      document.getElementById('lives').textContent = game.lives;
    }

    function endGame(won) {
      game.gameRunning = false;
      game.gameOver = true;
      game.gameWon = won;

      const overlay = document.createElement('div');
      overlay.className = 'game-over-screen';

      const title = won ? 'VICTORY!' : 'GAME OVER';
      const titleClass = won ? 'victory' : 'defeat';

      overlay.innerHTML = `
        <div class="game-over-text ${titleClass}">${title}</div>
        <div class="game-stats">
          Final Score: <span style="color: #00ff00;">${game.score}</span><br>
          Enemies Destroyed: <span style="color: #00ff00;">${game.score / 10}</span>
        </div>
        <div class="restart-hint">Click to Restart</div>
      `;

      overlay.addEventListener('click', () => {
        location.reload();
      });

      document.querySelector('.game-container').appendChild(overlay);
    }

    // ============================================
    // MAIN GAME LOOP
    // ============================================
    function gameLoop() {
      updatePlayer();
      updateBullets();
      updateEnemies();
      checkCollisions();
      updateParticles();
      updateUI();

      // Draw
      drawBackground();
      drawEnemies();
      drawBullets();
      drawPlayer();
      drawParticles();

      requestAnimationFrame(gameLoop);
    }

    // Start game
    gameLoop();
  </script>
</body>
</html>
