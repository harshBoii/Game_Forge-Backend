<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Top-Down Arena Shooter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0b0f1a 0%, #1a1f2e 100%);
      height: 100%;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .game-container {
      position: relative;
      background: radial-gradient(ellipse at center, #1a2847 0%, #0b0f1a 100%);
      border-radius: 12px;
      box-shadow:
        0 0 60px rgba(71, 198, 255, 0.3),
        inset 0 0 40px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    canvas {
      display: block;
      background: radial-gradient(ellipse at center, #162137 0%, #0a0f1a 100%);
      cursor: crosshair;
    }

    .ui-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #47c6ff;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 10;
      display: flex;
      gap: 30px;
    }

    .ui-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .timer {
      position: absolute;
      top: 12px;
      right: 12px;
      color: #47c6ff;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 10;
    }

    .timer.danger {
      color: #ff6b6b;
      animation: pulse 0.5s infinite;
    }

    .hint {
      position: absolute;
      right: 12px;
      bottom: 12px;
      color: #888;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid rgba(71, 198, 255, 0.2);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
      z-index: 10;
    }

    .game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      cursor: pointer;
      backdrop-filter: blur(3px);
    }

    .game-over-text {
      color: #47c6ff;
      font-size: 56px;
      font-weight: bold;
      text-shadow: 0 0 20px rgba(71, 198, 255, 0.8);
      margin-bottom: 20px;
      animation: pulse 1.5s infinite;
    }

    .game-over-text.lose {
      color: #ff6b6b;
      text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
    }

    .score-display {
      color: #fff;
      font-size: 24px;
      margin-bottom: 30px;
    }

    .restart-hint {
      color: #888;
      font-size: 14px;
      margin-top: 20px;
      animation: blink 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes blink {
      0%, 50%, 100% { opacity: 1; }
      25%, 75% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">
      <div class="ui-item">Score: <span id="score">0</span></div>
      <div class="ui-item">‚ù§Ô∏è <span id="health">5</span></div>
    </div>
    <div class="timer" id="timer">Time: 60</div>
    <div class="hint">WASD / Arrow keys to move ‚Ä¢ Click to shoot</div>
  </div>

  <script>
    // ============================================
    // CANVAS SETUP
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const maxWidth = Math.min(900, window.innerWidth - 20);
      const maxHeight = Math.min(700, window.innerHeight - 20);
      canvas.width = maxWidth;
      canvas.height = maxHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ============================================
    // GAME STATE (‚úÖ EASY TO MODIFY)
    // ============================================
    const game = {
      // Player (‚úÖ Adjust speed, fireRate, color)
      player: {
        x: 0,
        y: 0,
        radius: 18,
        color: '#47c6ff',
        speed: 3.5,           // ‚úÖ Movement speed
        fireRate: 200,        // ‚úÖ Milliseconds between shots
        lastFired: 0,
        rotation: 0,
        health: 5,            // ‚úÖ Starting health
        maxHealth: 5
      },

      // Bullets (‚úÖ Easy to adjust projectiles)
      bullets: [],
      bulletConfig: {
        speed: 7,             // ‚úÖ Bullet speed
        lifetime: 1800,       // ‚úÖ Milliseconds before bullet disappears
        radius: 5,
        color: '#ffff66'
      },

      // Enemies (‚úÖ Adjust spawn, speed, colors)
      enemies: [],
      enemyConfig: {
        spawnRate: 900,       // ‚úÖ Milliseconds between spawns
        baseSpeed: 1.5,       // ‚úÖ Enemy base speed
        speedVariance: 1.8,   // ‚úÖ Random speed variation
        hp: 1,                // ‚úÖ Health per enemy
        radius: 14,
        color: '#ff6b6b'      // ‚úÖ Enemy color
      },

      // Game state
      score: 0,
      timeLeft: 60,          // ‚úÖ Game duration in seconds
      gameRunning: true,
      gameWon: false,
      canShoot: true,
      
      // Input
      keys: {},
      mousePos: { x: 0, y: 0 }
    };

    // Initialize player position
    game.player.x = canvas.width / 2;
    game.player.y = canvas.height / 2;

    // ============================================
    // PARTICLES (Visual effects)
    // ============================================
    const particles = [];

    function createExplosion(x, y, color = '#ffe08a', count = 12) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 3 + Math.random() * 2;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          color: color,
          size: 3 + Math.random() * 2
        });
      }
    }

    function updateParticles() {
      particles.forEach((p, idx) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15; // gravity
        p.life -= 0.02;
        p.size -= 0.05;

        if (p.life <= 0) {
          particles.splice(idx, 1);
        }
      });
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color.replace(')', `, ${p.life * 0.7})`).replace('#ffe08a', 'rgba(255, 224, 138');
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(0.5, p.size), 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    document.addEventListener('keydown', (e) => {
      game.keys[e.key.toLowerCase()] = true;
    });
    document.addEventListener('keyup', (e) => {
      game.keys[e.key.toLowerCase()] = false;
    });
    document.addEventListener('mousemove', (e) => {
      game.mousePos.x = e.clientX;
      game.mousePos.y = e.clientY;
    });
    document.addEventListener('click', () => {
      if (game.gameRunning) playerShoot();
    });

    // ============================================
    // PLAYER LOGIC
    // ============================================
    function updatePlayer() {
      if (!game.gameRunning) return;

      const p = game.player;
      const moveSpeed = p.speed;

      // Movement (‚úÖ Easy to add more controls)
      if (game.keys['w'] || game.keys['arrowup']) p.y -= moveSpeed;
      if (game.keys['s'] || game.keys['arrowdown']) p.y += moveSpeed;
      if (game.keys['a'] || game.keys['arrowleft']) p.x -= moveSpeed;
      if (game.keys['d'] || game.keys['arrowright']) p.x += moveSpeed;

      // Clamp to world bounds
      p.x = Math.max(p.radius, Math.min(canvas.width - p.radius, p.x));
      p.y = Math.max(p.radius, Math.min(canvas.height - p.radius, p.y));

      // Rotation to mouse
      const dx = game.mousePos.x - canvas.getBoundingClientRect().left - p.x;
      const dy = game.mousePos.y - canvas.getBoundingClientRect().top - p.y;
      p.rotation = Math.atan2(dy, dx);
    }

    function playerShoot() {
      const now = Date.now();
      if (now - game.player.lastFired < game.player.fireRate) return;
      game.player.lastFired = now;

      const p = game.player;
      const bullet = {
        x: p.x + Math.cos(p.rotation) * 20,
        y: p.y + Math.sin(p.rotation) * 20,
        vx: Math.cos(p.rotation) * game.bulletConfig.speed,
        vy: Math.sin(p.rotation) * game.bulletConfig.speed,
        life: game.bulletConfig.lifetime,
        radius: game.bulletConfig.radius
      };

      game.bullets.push(bullet);
    }

    // ============================================
    // BULLET LOGIC
    // ============================================
    function updateBullets() {
      game.bullets.forEach((b, idx) => {
        b.x += b.vx;
        b.y += b.vy;
        b.life -= 1;

        // Remove off-screen bullets
        if (
          b.x < 0 || b.x > canvas.width ||
          b.y < 0 || b.y > canvas.height ||
          b.life <= 0
        ) {
          game.bullets.splice(idx, 1);
        }
      });
    }

    // ============================================
    // ENEMY LOGIC
    // ============================================
    let lastSpawnTime = 0;

    function spawnEnemy() {
      const now = Date.now();
      if (now - lastSpawnTime < game.enemyConfig.spawnRate) return;
      lastSpawnTime = now;

      const edge = Math.floor(Math.random() * 4);
      let x, y;

      if (edge === 0) { // Top
        x = Math.random() * canvas.width;
        y = -20;
      } else if (edge === 1) { // Right
        x = canvas.width + 20;
        y = Math.random() * canvas.height;
      } else if (edge === 2) { // Bottom
        x = Math.random() * canvas.width;
        y = canvas.height + 20;
      } else { // Left
        x = -20;
        y = Math.random() * canvas.height;
      }

      const speed = game.enemyConfig.baseSpeed + 
                    Math.random() * game.enemyConfig.speedVariance;

      game.enemies.push({
        x: x,
        y: y,
        radius: game.enemyConfig.radius,
        speed: speed,
        hp: game.enemyConfig.hp,
        color: game.enemyConfig.color
      });
    }

    function updateEnemies() {
      spawnEnemy();

      game.enemies.forEach((e, idx) => {
        // Chase player
        const dx = game.player.x - e.x;
        const dy = game.player.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          e.x += (dx / dist) * e.speed;
          e.y += (dy / dist) * e.speed;
        }

        // Rotation to player
        e.rotation = Math.atan2(dy, dx);

        // Remove off-screen
        if (e.x < -50 || e.x > canvas.width + 50 ||
            e.y < -50 || e.y > canvas.height + 50) {
          game.enemies.splice(idx, 1);
        }
      });
    }

    // ============================================
    // COLLISION DETECTION
    // ============================================
    function checkCollisions() {
      // Bullets vs Enemies
      game.bullets.forEach((b, bIdx) => {
        game.enemies.forEach((e, eIdx) => {
          const dx = b.x - e.x;
          const dy = b.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < b.radius + e.radius) {
            e.hp -= 1;

            game.bullets.splice(bIdx, 1);

            if (e.hp <= 0) {
              createExplosion(e.x, e.y, '#ffe08a', 12);
              game.enemies.splice(eIdx, 1);
              game.score += 10;
            }
          }
        });
      });

      // Player vs Enemies
      game.enemies.forEach((e, idx) => {
        const dx = game.player.x - e.x;
        const dy = game.player.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < game.player.radius + e.radius) {
          createExplosion(game.player.x, game.player.y, '#ff4444', 8);
          game.enemies.splice(idx, 1);
          game.player.health -= 1;

          if (game.player.health <= 0) {
            endGame(false);
          }
        }
      });
    }

    // ============================================
    // RENDERING
    // ============================================
    function drawBackground() {
      const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0,
                                            canvas.width / 2, canvas.height / 2, 800);
      grad.addColorStop(0, '#1a2847');
      grad.addColorStop(1, '#0a0f1a');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid overlay (subtle)
      ctx.strokeStyle = 'rgba(71, 198, 255, 0.05)';
      ctx.lineWidth = 1;
      const gridSize = 50;
      for (let i = 0; i <= canvas.width; i += gridSize) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i <= canvas.height; i += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(canvas.width, i);
        ctx.stroke();
      }
    }

    function drawPlayer() {
      const p = game.player;

      // Glow effect
      ctx.fillStyle = `rgba(71, 198, 255, 0.2)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius + 15, 0, Math.PI * 2);
      ctx.fill();

      // Body
      const bodyGrad = ctx.createRadialGradient(p.x - 5, p.y - 5, 0, p.x, p.y, p.radius);
      bodyGrad.addColorStop(0, '#7fd9ff');
      bodyGrad.addColorStop(1, p.color);
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#ffffff';
      const eyeOffsetX = Math.cos(p.rotation) * 6;
      const eyeOffsetY = Math.sin(p.rotation) * 6;
      ctx.beginPath();
      ctx.arc(p.x - 4 + eyeOffsetX, p.y - 4 + eyeOffsetY, 4, 0, Math.PI * 2);
      ctx.arc(p.x + 4 + eyeOffsetX, p.y - 4 + eyeOffsetY, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(p.x - 4 + eyeOffsetX, p.y - 4 + eyeOffsetY, 2, 0, Math.PI * 2);
      ctx.arc(p.x + 4 + eyeOffsetX, p.y - 4 + eyeOffsetY, 2, 0, Math.PI * 2);
      ctx.fill();

      // Weapon indicator
      ctx.strokeStyle = '#47c6ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      const aimLength = p.radius + 15;
      ctx.lineTo(
        p.x + Math.cos(p.rotation) * aimLength,
        p.y + Math.sin(p.rotation) * aimLength
      );
      ctx.stroke();
    }

    function drawBullets() {
      game.bullets.forEach(b => {
        // Glow
        ctx.fillStyle = `rgba(255, 255, 102, 0.3)`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius + 6, 0, Math.PI * 2);
        ctx.fill();

        // Bullet
        const bulletGrad = ctx.createRadialGradient(b.x - 2, b.y - 2, 0, b.x, b.y, b.radius);
        bulletGrad.addColorStop(0, '#ffff99');
        bulletGrad.addColorStop(1, game.bulletConfig.color);
        ctx.fillStyle = bulletGrad;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawEnemies() {
      game.enemies.forEach(e => {
        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(e.x, e.y + e.radius + 3, e.radius, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glow
        ctx.fillStyle = `rgba(255, 107, 107, 0.2)`;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius + 12, 0, Math.PI * 2);
        ctx.fill();

        // Body
        const enemyGrad = ctx.createRadialGradient(e.x - 3, e.y - 3, 0, e.x, e.y, e.radius);
        enemyGrad.addColorStop(0, '#ff9999');
        enemyGrad.addColorStop(1, e.color);
        ctx.fillStyle = enemyGrad;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fill();

        // Angry mouth
        ctx.fillStyle = '#000000';
        ctx.fillRect(e.x - 6, e.y + 4, 12, 6);

        // HP indicator (if damaged)
        if (e.hp < game.enemyConfig.hp) {
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.radius + 3, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
    }

    // ============================================
    // GAME STATE & UI
    // ============================================
    let lastTimeUpdate = Date.now();

    function updateGameState() {
      if (!game.gameRunning) return;

      const now = Date.now();
      if (now - lastTimeUpdate > 1000) {
        game.timeLeft -= 1;
        lastTimeUpdate = now;

        if (game.timeLeft <= 0) {
          endGame(true); // Win
        }
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = game.score;
      document.getElementById('health').textContent = game.player.health;

      const timerEl = document.getElementById('timer');
      timerEl.textContent = `Time: ${game.timeLeft}`;

      if (game.timeLeft <= 10) {
        timerEl.classList.add('danger');
      } else {
        timerEl.classList.remove('danger');
      }
    }

    function endGame(won = false) {
      game.gameRunning = false;
      game.gameWon = won;

      const overlay = document.createElement('div');
      overlay.className = 'game-over-screen';

      const msg = won ? 'üéâ You Survived! üéâ' : 'üíÄ Game Over üíÄ';
      const textClass = won ? '' : 'lose';

      overlay.innerHTML = `
        <div class="game-over-text ${textClass}">${msg}</div>
        <div class="score-display">Score: ${game.score}</div>
        <div class="restart-hint">Click to Restart</div>
      `;

      overlay.addEventListener('click', () => {
        location.reload();
      });

      document.querySelector('.game-container').appendChild(overlay);
    }

    // ============================================
    // MAIN GAME LOOP
    // ============================================
    function gameLoop() {
      updatePlayer();
      updateBullets();
      updateEnemies();
      checkCollisions();
      updateParticles();
      updateGameState();
      updateUI();

      // Draw
      drawBackground();
      drawEnemies();
      drawBullets();
      drawPlayer();
      drawParticles();

      requestAnimationFrame(gameLoop);
    }

    // Start game
    gameLoop();
  </script>
</body>
</html>
