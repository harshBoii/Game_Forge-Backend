"""
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pac-Man Maze - Phaser Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html,body { margin:0; padding:0; background:#000; height:100%; }
    .hint { position: absolute; right: 12px; top: 12px; color:#ddd; font-family: monospace; font-size:13px; background: rgba(0,0,0,0.25); padding:8px; border-radius:6px; z-index: 1000;}
  </style>
</head>
<body>
  <div class="hint">Arrow keys to move • Collect dots • Avoid ghosts • Power pellets let you eat ghosts!</div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>

  <!-- REGION:SCENE_CLASS_START -->
  <script>
  class MazeScene extends Phaser.Scene {
    constructor() { super('MazeScene'); }
    
    preload() {
      this.generateTextures();
    }
    
    generateTextures() {
      // Pac-Man texture
      if (!this.textures.exists('pac')) {
        const g = this.add.graphics();
        g.fillStyle(0xffcc00, 1);
        g.slice(16, 16, 14, Phaser.Math.DegToRad(30), Phaser.Math.DegToRad(330), true);
        g.fillPath();
        g.generateTexture('pac', 32, 32);
        g.destroy();
      }

      // Dot texture
      if (!this.textures.exists('dot')) {
        const g = this.add.graphics();
        g.fillStyle(0xffdd44, 1);
        g.fillCircle(8, 8, 3);
        g.generateTexture('dot', 16, 16);
        g.destroy();
      }

      // Power pellet texture
      if (!this.textures.exists('pellet')) {
        const g = this.add.graphics();
        g.fillStyle(0xff00ff, 1);
        g.fillCircle(16, 16, 8);
        g.generateTexture('pellet', 32, 32);
        g.destroy();
      }

      // Ghost textures
      const ghostColors = [0xff5555, 0x55ffff, 0xff55ff, 0xffaa55];
      ghostColors.forEach((color, i) => {
        if (!this.textures.exists('ghost' + i)) {
          const g = this.add.graphics();
          g.fillStyle(color, 1);
          g.fillRoundedRect(2, 2, 28, 28, 8);
          g.fillStyle(0xffffff, 1);
          g.fillCircle(10, 12, 4);
          g.fillCircle(22, 12, 4);
          g.fillStyle(0x000000, 1);
          g.fillCircle(10, 12, 2);
          g.fillCircle(22, 12, 2);
          g.generateTexture('ghost' + i, 32, 32);
          g.destroy();
        }
      });
    }
    
    create() {
      this.cellSize = 32;
      this.moveSpeed = 100;
      
      this.createMaze();
      this.createPlayer();
      this.createGhosts();
      this.createDots();
      this.createUI();

      this.cursors = this.input.keyboard.createCursorKeys();
      
      this.physics.add.overlap(this.player, this.dots, this.collectDot, null, this);
      this.physics.add.collider(this.player, this.walls);
      this.physics.add.collider(this.ghosts, this.walls);
      this.physics.add.overlap(this.player, this.ghosts, this.hitGhost, null, this);
      
      this.powerMode = false;
      this.powerTimer = null;
    }

    update() {
      this.handlePlayerMovement();
      this.updateGhosts();
    }

    createMaze() {
      this.walls = this.physics.add.staticGroup();
      
      this.layout = [
        '########################',
        '#..........##..........#',
        '#.####.###.##.###.####.#',
        '#P.....................P#',
        '#.####.#.######.#.####.#',
        '#......#....##....#....#',
        '######.#### ## ####.####',
        '#......................#',
        '########################'
      ];
      
      this.layout.forEach((row, y) => {
        row.split('').forEach((cell, x) => {
          if (cell === '#') {
            const block = this.add.rectangle(
              x * this.cellSize + 16, 
              y * this.cellSize + 16, 
              this.cellSize, 
              this.cellSize, 
              0x2233aa
            );
            this.physics.add.existing(block, true);
            this.walls.add(block);
          }
        });
      });
    }

    createPlayer() {
      this.player = this.physics.add.sprite(64, 64, 'pac');
      this.player.setCollideWorldBounds(true);
      this.player.body.setSize(28, 28).setOffset(2, 2);
      this.player.direction = null;
      this.player.nextDirection = null;
    }

    handlePlayerMovement() {
      const p = this.player;
      
      // Queue next direction
      if (this.cursors.left.isDown) p.nextDirection = 'left';
      else if (this.cursors.right.isDown) p.nextDirection = 'right';
      else if (this.cursors.up.isDown) p.nextDirection = 'up';
      else if (this.cursors.down.isDown) p.nextDirection = 'down';
      
      // Try to change direction if at grid center
      if (this.isNearGridCenter(p)) {
        if (p.nextDirection && this.canMove(p, p.nextDirection)) {
          p.direction = p.nextDirection;
          p.nextDirection = null;
        }
      }
      
      // Move in current direction
      p.body.setVelocity(0);
      if (p.direction) {
        if (this.canMove(p, p.direction)) {
          switch (p.direction) {
            case 'left':
              p.body.setVelocityX(-this.moveSpeed);
              p.setAngle(180);
              break;
            case 'right':
              p.body.setVelocityX(this.moveSpeed);
              p.setAngle(0);
              break;
            case 'up':
              p.body.setVelocityY(-this.moveSpeed);
              p.setAngle(-90);
              break;
            case 'down':
              p.body.setVelocityY(this.moveSpeed);
              p.setAngle(90);
              break;
          }
        } else {
          p.direction = null;
        }
      }
    }

    isNearGridCenter(sprite) {
      const gridX = Math.round(sprite.x / this.cellSize) * this.cellSize;
      const gridY = Math.round(sprite.y / this.cellSize) * this.cellSize;
      const dx = Math.abs(sprite.x - gridX);
      const dy = Math.abs(sprite.y - gridY);
      return dx < 4 && dy < 4;
    }

    canMove(sprite, direction) {
      const checkDist = this.cellSize;
      let checkX = sprite.x;
      let checkY = sprite.y;
      
      switch (direction) {
        case 'left': checkX -= checkDist; break;
        case 'right': checkX += checkDist; break;
        case 'up': checkY -= checkDist; break;
        case 'down': checkY += checkDist; break;
      }
      
      const gridX = Math.floor(checkX / this.cellSize);
      const gridY = Math.floor(checkY / this.cellSize);
      
      if (gridY < 0 || gridY >= this.layout.length || 
          gridX < 0 || gridX >= this.layout[0].length) {
        return false;
      }
      
      return this.layout[gridY][gridX] !== '#';
    }

    createGhosts() {
      this.ghosts = this.physics.add.group();
      
      const spawnPositions = [
        { x: 11, y: 4, dir: 'left' },
        { x: 12, y: 4, dir: 'right' },
        { x: 11, y: 5, dir: 'up' },
        { x: 12, y: 5, dir: 'down' }
      ];
      
      for (let i = 0; i < 4; i++) {
        const pos = spawnPositions[i];
        const ghost = this.ghosts.create(
          pos.x * this.cellSize + 16, 
          pos.y * this.cellSize + 16, 
          'ghost' + i
        );
        ghost.setCollideWorldBounds(true);
        ghost.body.setSize(28, 28).setOffset(2, 2);
        ghost.direction = pos.dir;
        ghost.updateTimer = 0;
        ghost.isVulnerable = false;
      }
    }

    updateGhosts() {
      this.ghosts.children.entries.forEach(ghost => {
        if (!ghost.active) return;
        
        ghost.updateTimer++;
        
        // Update AI every 20 frames
        if (ghost.updateTimer > 20) {
          ghost.updateTimer = 0;
          
          if (this.isNearGridCenter(ghost)) {
            if (!ghost.isVulnerable) {
              this.ghostChaseAI(ghost);
            } else {
              this.ghostFleeAI(ghost);
            }
          }
        }
        
        // Move in current direction
        ghost.body.setVelocity(0);
        const speed = ghost.isVulnerable ? 60 : 80;
        
        if (ghost.direction && this.canMove(ghost, ghost.direction)) {
          switch (ghost.direction) {
            case 'left': ghost.body.setVelocityX(-speed); break;
            case 'right': ghost.body.setVelocityX(speed); break;
            case 'up': ghost.body.setVelocityY(-speed); break;
            case 'down': ghost.body.setVelocityY(speed); break;
          }
        } else {
          this.ghostRandomDirection(ghost);
        }
      });
    }

    ghostChaseAI(ghost) {
      const dx = this.player.x - ghost.x;
      const dy = this.player.y - ghost.y;
      
      const directions = [];
      if (Math.abs(dx) > Math.abs(dy)) {
        directions.push(dx > 0 ? 'right' : 'left');
        directions.push(dy > 0 ? 'down' : 'up');
      } else {
        directions.push(dy > 0 ? 'down' : 'up');
        directions.push(dx > 0 ? 'right' : 'left');
      }
      
      for (let dir of directions) {
        if (this.canMove(ghost, dir)) {
          ghost.direction = dir;
          return;
        }
      }
      
      this.ghostRandomDirection(ghost);
    }

    ghostFleeAI(ghost) {
      const dx = this.player.x - ghost.x;
      const dy = this.player.y - ghost.y;
      
      const directions = [];
      if (Math.abs(dx) > Math.abs(dy)) {
        directions.push(dx > 0 ? 'left' : 'right');
        directions.push(dy > 0 ? 'up' : 'down');
      } else {
        directions.push(dy > 0 ? 'up' : 'down');
        directions.push(dx > 0 ? 'left' : 'right');
      }
      
      for (let dir of directions) {
        if (this.canMove(ghost, dir)) {
          ghost.direction = dir;
          return;
        }
      }
      
      this.ghostRandomDirection(ghost);
    }

    ghostRandomDirection(ghost) {
      const validDirs = ['left', 'right', 'up', 'down']
        .filter(dir => this.canMove(ghost, dir));
      
      if (validDirs.length > 0) {
        ghost.direction = Phaser.Utils.Array.GetRandom(validDirs);
      }
    }

    createDots() {
      this.dots = this.physics.add.group();
      
      this.layout.forEach((row, y) => {
        row.split('').forEach((cell, x) => {
          if (cell === '.') {
            const dot = this.dots.create(
              x * this.cellSize + 16, 
              y * this.cellSize + 16, 
              'dot'
            );
            dot.body.setCircle(3);
          } else if (cell === 'P') {
            const pellet = this.dots.create(
              x * this.cellSize + 16, 
              y * this.cellSize + 16, 
              'pellet'
            );
            pellet.isPowerPellet = true;
            pellet.body.setCircle(8);
            
            // Pulse animation
            this.tweens.add({
              targets: pellet,
              scale: 1.3,
              duration: 400,
              yoyo: true,
              repeat: -1
            });
          }
        });
      });
    }

    collectDot(player, dot) {
      dot.destroy();
      
      if (dot.isPowerPellet) {
        this.score += 50;
        this.activatePowerMode();
      } else {
        this.score += 10;
      }
      
      this.scoreText.setText('Score: ' + this.score);
      
      if (this.dots.countActive() === 0) {
        this.showGameOver(true);
      }
    }

    activatePowerMode() {
      this.powerMode = true;
      
      if (this.powerTimer) {
        this.powerTimer.remove();
      }
      
      this.ghosts.children.entries.forEach(ghost => {
        if (ghost.active) {
          ghost.isVulnerable = true;
          ghost.setTint(0x0000ff);
        }
      });
      
      this.powerTimer = this.time.delayedCall(7000, () => {
        this.powerMode = false;
        this.ghosts.children.entries.forEach(ghost => {
          if (ghost.active) {
            ghost.isVulnerable = false;
            ghost.clearTint();
          }
        });
      });
    }

    hitGhost(player, ghost) {
      if (this.powerMode && ghost.isVulnerable) {
        // Eat ghost
        ghost.setPosition(11.5 * this.cellSize, 4.5 * this.cellSize);
        ghost.isVulnerable = false;
        ghost.clearTint();
        this.score += 200;
        this.scoreText.setText('Score: ' + this.score);
      } else if (!ghost.isVulnerable) {
        // Game over
        this.showGameOver(false);
      }
    }

    createUI() {
      this.score = 0;
      this.scoreText = this.add.text(16, 16, 'Score: 0', {
        fontFamily: 'monospace',
        fontSize: 20,
        color: '#fff',
        backgroundColor: '#000',
        padding: { x: 8, y: 4 }
      });
    }

    showGameOver(win) {
      this.physics.pause();
      
      const msg = win ? 'You Win!' : 'Game Over';
      const color = win ? '#ffff00' : '#ff0000';
      
      this.add.text(
        this.scale.width / 2,
        this.scale.height / 2 - 30,
        msg,
        {
          fontFamily: 'monospace',
          fontSize: 48,
          color: color,
          stroke: '#000',
          strokeThickness: 6
        }
      ).setOrigin(0.5);
      
      this.add.text(
        this.scale.width / 2,
        this.scale.height / 2 + 30,
        `Final Score: ${this.score}`,
        {
          fontFamily: 'monospace',
          fontSize: 24,
          color: '#fff'
        }
      ).setOrigin(0.5);
      
      this.add.text(
        this.scale.width / 2,
        this.scale.height / 2 + 70,
        'Click to Restart',
        {
          fontFamily: 'monospace',
          fontSize: 16,
          color: '#ccc'
        }
      ).setOrigin(0.5);
      
      this.input.once('pointerdown', () => this.scene.restart());
    }
  }
  </script>
  <!-- REGION:SCENE_CLASS_END -->

  <!-- REGION:CONFIG_START -->
  <script>
  const config = {
    type: Phaser.AUTO,
    width: 768,
    height: 288,
    backgroundColor: 0x000000,
    physics: {
      default: 'arcade',
      arcade: { 
        gravity: { y: 0 }, 
        debug: false 
      }
    },
    scene: [MazeScene]
  };
  </script>
  <!-- REGION:CONFIG_END -->

  <!-- REGION:GAME_INIT_START -->
  <script>
  window.onload = () => {
    const game = new Phaser.Game(config);
  };
  </script>
  <!-- REGION:GAME_INIT_END -->

</body>
</html>
