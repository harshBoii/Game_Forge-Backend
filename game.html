
<!DOCTYPE html>
<html>
<head>
    <title>Untitled Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000000; }
    </style>
</head>
<body>

<script>
    // Game configuration
    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: '#000000', // Black background as per color palette
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }, // No gravity in this arcade game
                debug: false // Set to true to visualize physics bodies for debugging
            }
        }
        // The 'scene' property referencing global functions (preload, create, update)
        // is semantically incorrect when using a class-based scene.
        // It's removed because game.scene.add('GameScene', GameScene, true); explicitly
        // starts the GameScene class.
    };

    // Game variables (declared globally for easy access within the scene)
    let player; // The physics sprite for the player
    let playerGraphics; // The graphics object that draws the player's visual
    let playerHealth = 100;
    let score = 0;
    let healthText;
    let scoreText;
    let gameOverText;
    let restartText;
    let enemies; // Phaser Group for enemy physics sprites
    let projectiles; // Phaser Group for projectile physics sprites
    let cursors; // Input handler for WASD and Spacebar
    let lastFired = 0; // Timestamp for controlling player fire rate
    const PLAYER_FIRE_RATE = 200; // milliseconds between shots
    const PLAYER_SPEED = 200; // pixels per second
    const PROJECTILE_SPEED = 400; // pixels per second
    const ENEMY_SPEED = 50; // pixels per second
    const ENEMY_SPAWN_RATE = 1500; // milliseconds between enemy spawns
    let lastEnemySpawn = 0; // Timestamp for controlling enemy spawn rate
    let isGameOver = false; // Flag to track game state
    let explosionParticles; // Particle emitter for explosions

    // --- Custom Graphics Functions for Procedural Characters ---

    /**
     * Draws a player character shape onto a Phaser.GameObjects.Graphics object.
     * The character is drawn centered around (0,0) of the graphics object.
     * @param {Phaser.GameObjects.Graphics} graphics - The graphics object to draw on.
     * @param {number} size - Base size for the character.
     */
    function drawPlayerCharacter(graphics, size = 20) {
        graphics.clear(); // Clear previous drawings from this graphics object
        graphics.fillStyle(0xFFFFFF, 1); // White color for the character

        // Body (rounded rectangle) - centered at (0,0)
        graphics.fillRoundedRect(-size, -size, size * 2, size * 2, size * 0.5);

        // Head (circle on top of body)
        graphics.fillCircle(0, -size * 1.2, size * 0.8);

        // Eyes (two small black circles on head)
        graphics.fillStyle(0x000000, 1); // Black for eyes
        graphics.fillCircle(-size * 0.3, -size * 1.3, size * 0.15);
        graphics.fillCircle(size * 0.3, -size * 1.3, size * 0.15);
        graphics.fillStyle(0xFFFFFF, 1); // Reset to white

        // Arms (rounded rectangles, slightly extended)
        graphics.fillRoundedRect(-size * 1.5, -size * 0.5, size * 0.6, size * 1.5, size * 0.3); // Left arm
        graphics.fillRoundedRect(size * 0.9, -size * 0.5, size * 0.6, size * 1.5, size * 0.3); // Right arm

        // Legs (rounded rectangles, slightly extended)
        graphics.fillRoundedRect(-size * 0.7, size * 0.8, size * 0.5, size * 1.2, size * 0.3); // Left leg
        graphics.fillRoundedRect(size * 0.2, size * 0.8, size * 0.5, size * 1.2, size * 0.3); // Right leg
    }

    /**
     * Draws an enemy character shape onto a Phaser.GameObjects.Graphics object.
     * The character is drawn centered around (0,0) of the graphics object.
     * @param {Phaser.GameObjects.Graphics} graphics - The graphics object to draw on.
     * @param {number} size - Base size for the character.
     */
    function drawEnemyCharacter(graphics, size = 15) {
        graphics.clear(); // Clear previous drawings
        graphics.fillStyle(0xFFFFFF, 1); // White color for enemies

        // Main body (more organic, spiky shape) - centered at (0,0)
        graphics.beginPath();
        graphics.moveTo(0, -size); // Top point
        graphics.lineTo(size * 0.5, -size * 0.8);
        graphics.lineTo(size, 0); // Right point
        graphics.lineTo(size * 0.8, size * 0.5);
        graphics.lineTo(0, size); // Bottom point
        graphics.lineTo(-size * 0.8, size * 0.5);
        graphics.lineTo(-size, 0); // Left point
        graphics.lineTo(-size * 0.5, -size * 0.8);
        graphics.closePath();
        graphics.fillPath();

        // Eye (single, angry-looking black eye)
        graphics.fillStyle(0x000000, 1); // Black for eye
        graphics.fillCircle(0, -size * 0.3, size * 0.2); // Center eye
        graphics.fillStyle(0xFFFFFF, 1); // Reset to white
    }

    /**
     * Draws a projectile shape onto a Phaser.GameObjects.Graphics object.
     * The projectile is drawn centered around (0,0) of the graphics object.
     * @param {Phaser.GameObjects.Graphics} graphics - The graphics object to draw on.
     * @param {number} size - Base size for the projectile.
     */
    function drawProjectile(graphics, size = 5) {
        graphics.clear(); // Clear previous drawings
        graphics.fillStyle(0xFFFFFF, 1); // White color for projectiles

        // Elongated diamond/rocket shape - centered at (0,0)
        graphics.beginPath();
        graphics.moveTo(0, -size * 1.5); // Top tip
        graphics.lineTo(size * 0.5, 0);
        graphics.lineTo(0, size * 1.5); // Bottom tip
        graphics.lineTo(-size * 0.5, 0);
        graphics.closePath();
        graphics.fillPath();
    }

    // Main game scene class
    class GameScene extends Phaser.Scene {
        constructor() {
            super({ key: 'GameScene' });
        }

        preload() {
            // No external assets to load as everything is drawn procedurally
        }

        create() {
            // --- Game State Initialization ---
            playerHealth = 100;
            score = 0;
            isGameOver = false;
            lastFired = 0;
            lastEnemySpawn = 0;

            // --- Player Setup ---
            // Create a Graphics object for the player's visual appearance
            playerGraphics = this.add.graphics();
            // Create an invisible physics sprite for player collision and movement
            player = this.physics.add.sprite(config.width / 2, config.height - 50);
            player.setOrigin(0.5, 0.5); // Center the physics body
            player.body.setCollideWorldBounds(true); // Player stays within screen bounds
            player.body.setSize(40, 40); // Set a reasonable collision box size
            player.body.setOffset(-20, -20); // Adjust offset to center the body on the visual character
            drawPlayerCharacter(playerGraphics, 20); // Initial draw of the player character

            // --- Enemy Group Setup ---
            enemies = this.physics.add.group({
                classType: Phaser.GameObjects.Sprite, // Enemies are physics sprites
                runChildUpdate: true // Allows individual enemy sprites to update (though not used for movement directly here)
            });

            // --- Projectile Group Setup ---
            projectiles = this.physics.add.group({
                classType: Phaser.GameObjects.Sprite, // Projectiles are physics sprites
                maxSize: 10, // Limit active projectiles to improve performance
                runChildUpdate: true
            });

            // --- UI Text Setup ---
            scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#FFFFFF' });
            healthText = this.add.text(config.width - 16, 16, 'Health: 100', { fontSize: '24px', fill: '#FFFFFF' }).setOrigin(1, 0);

            // --- Game Over Text Setup (initially hidden) ---
            gameOverText = this.add.text(config.width / 2, config.height / 2 - 50, 'GAME OVER', { fontSize: '48px', fill: '#FFFFFF' }).setOrigin(0.5);
            gameOverText.setVisible(false);
            restartText = this.add.text(config.width / 2, config.height / 2 + 20, 'Press R to Restart', { fontSize: '24px', fill: '#FFFFFF' }).setOrigin(0.5);
            restartText.setVisible(false);

            // --- Input Controls Setup (WASD + Spacebar for fire, R for restart) ---
            cursors = this.input.keyboard.addKeys({
                up: 'W',
                down: 'S',
                left: 'A',
                right: 'D',
                fire: 'SPACE',
                restart: 'R'
            });

            // --- Collision Handlers ---
            // Player vs. Enemies: Calls hitPlayer when collision occurs
            this.physics.add.collider(player, enemies, this.hitPlayer, null, this);
            // Projectiles vs. Enemies: Calls hitEnemy when collision occurs
            this.physics.add.collider(projectiles, enemies, this.hitEnemy, null, this);

            // --- Particle Emitter Setup for Explosions ---
            // Changed 'pixel' to '__DEFAULT' and removed 'frame' as suggested.
            // '__DEFAULT' is a built-in white pixel texture that Phaser always provides,
            // preventing the "texture key not loaded" error. The custom onParticleRender
            // callback handles the actual drawing, making the base texture irrelevant
            // for visual output but necessary for initialization.
            explosionParticles = this.add.particles(0, 0, '__DEFAULT', {
                lifespan: 500, // Particles last for 500ms
                speed: { min: 50, max: 150 }, // Random speed for particles
                angle: { min: 0, max: 360 }, // Emit in all directions
                gravityY: 0, // No gravity
                scale: { start: 0.5, end: 0 }, // Particles shrink over time
                quantity: 15, // Number of particles per burst
                blendMode: 'ADD', // Additive blending for a glowing effect
                on: false // Emitter starts off, will be triggered manually
            });

            // Custom rendering for particles to draw white circles
            explosionParticles.manager.emitters.list[0].onParticleRender = (particle, context) => {
                context.fillStyle = '#FFFFFF'; // White color for particles
                context.beginPath();
                // Draw a circle at the particle's local coordinates, scaled by its current scale
                context.arc(particle.x, particle.y, particle.scale * 5, 0, Math.PI * 2);
                context.fill();
            };
        }

        update(time, delta) {
            // If game is over, only check for restart input
            if (isGameOver) {
                if (cursors.restart.isDown) {
                    this.scene.restart(); // Restart the current scene
                }
                return; // Stop further update logic
            }

            // --- Player Movement ---
            player.body.setVelocity(0); // Reset velocity each frame to stop movement when keys are released

            if (cursors.left.isDown) {
                player.body.setVelocityX(-PLAYER_SPEED);
            } else if (cursors.right.isDown) {
                player.body.setVelocityX(PLAYER_SPEED);
            }

            if (cursors.up.isDown) {
                player.body.setVelocityY(-PLAYER_SPEED);
            } else if (cursors.down.isDown) {
                player.body.setVelocityY(PLAYER_SPEED);
            }

            // Update the player's visual position to match its physics body
            playerGraphics.x = player.x;
            playerGraphics.y = player.y;

            // --- Player Firing ---
            if (cursors.fire.isDown && time > lastFired + PLAYER_FIRE_RATE) {
                this.fireProjectile(player.x, player.y - 20); // Fire projectile from player's top
                lastFired = time; // Update last fired timestamp
            }

            // --- Enemy Spawning ---
            if (time > lastEnemySpawn + ENEMY_SPAWN_RATE) {
                this.spawnEnemy();
                lastEnemySpawn = time; // Update last enemy spawn timestamp
            }

            // --- Update Enemies (move towards player and update visuals) ---
            enemies.children.each(function(enemy) {
                if (enemy.active) {
                    // Move enemy towards the player
                    this.physics.moveToObject(enemy, player, ENEMY_SPEED);

                    // Ensure enemy has a graphics object and update its position
                    if (!enemy.graphics) {
                        enemy.graphics = this.add.graphics();
                        drawEnemyCharacter(enemy.graphics, 15); // Draw character once when activated
                    }
                    enemy.graphics.x = enemy.x;
                    enemy.graphics.y = enemy.y;
                } else if (enemy.graphics) {
                    // Clear enemy drawing when it's inactive
                    enemy.graphics.clear();
                }
            }, this);

            // --- Update Projectiles (move upwards and update visuals) ---
            projectiles.children.each(function(projectile) {
                if (projectile.active) {
                    // Deactivate projectile if it goes off-screen
                    if (projectile.y < 0) {
                        projectile.disableBody(true, true);
                    }

                    // Ensure projectile has a graphics object and update its position
                    if (!projectile.graphics) {
                        projectile.graphics = this.add.graphics();
                        drawProjectile(projectile.graphics, 5); // Draw projectile once when activated
                    }
                    projectile.graphics.x = projectile.x;
                    projectile.graphics.y = projectile.y;
                } else if (projectile.graphics) {
                    // Clear projectile drawing when it's inactive
                    projectile.graphics.clear();
                }
            }, this);
        }

        /**
         * Fires a projectile from the given coordinates.
         * @param {number} x - X coordinate to spawn the projectile.
         * @param {number} y - Y coordinate to spawn the projectile.
         */
        fireProjectile(x, y) {
            // Get an inactive projectile from the group (or create a new one if group isn't full)
            let projectile = projectiles.get(x, y);

            if (projectile) {
                // Activate the projectile and enable its physics body
                projectile.setActive(true).setVisible(true);
                projectile.body.enable = true;
                projectile.body.reset(x, y); // Reset position

                // Set projectile velocity to move upwards
                projectile.body.setVelocityY(-PROJECTILE_SPEED);
                // Set collision box size and offset for the visual shape
                projectile.body.setSize(10, 30);
                projectile.body.setOffset(-5, -15);

                // Ensure it has a graphics object and draw it
                if (!projectile.graphics) {
                    projectile.graphics = this.add.graphics();
                }
                drawProjectile(projectile.graphics, 5);
                projectile.graphics.x = projectile.x;
                projectile.graphics.y = projectile.y;
            }
        }

        /**
         * Spawns an enemy at a random X position at the top of the screen.
         */
        spawnEnemy() {
            // Get an inactive enemy from the group (or create a new one)
            let enemy = enemies.get(Phaser.Math.Between(50, config.width - 50), 0); // Spawn at random X, top of screen

            if (enemy) {
                // Activate the enemy and enable its physics body
                enemy.setActive(true).setVisible(true);
                enemy.body.enable = true;
                enemy.body.reset(enemy.x, enemy.y); // Reset position

                // Set initial velocity (will be overridden by moveToObject in update)
                enemy.body.setVelocityY(ENEMY_SPEED);
                // Set collision box (circle for rounded enemy) and offset
                enemy.body.setCircle(15);
                enemy.body.setOffset(-15, -15);

                // Ensure it has a graphics object and draw it
                if (!enemy.graphics) {
                    enemy.graphics = this.add.graphics();
                }
                drawEnemyCharacter(enemy.graphics, 15);
                enemy.graphics.x = enemy.x;
                enemy.graphics.y = enemy.y;
            }
        }

        /**
         * Handler for when the player collides with an enemy.
         * @param {Phaser.GameObjects.Sprite} playerSprite - The player's physics sprite.
         * @param {Phaser.GameObjects.Sprite} enemy - The enemy physics sprite.
         */
        hitPlayer(playerSprite, enemy) {
            if (isGameOver) return; // Prevent multiple game over triggers

            enemy.disableBody(true, true); // Deactivate enemy and remove from display
            if (enemy.graphics) {
                enemy.graphics.clear(); // Clear enemy visual drawing
            }

            playerHealth -= 20; // Reduce player health
            healthText.setText('Health: ' + playerHealth);

            // Emit explosion particles at the player's position
            explosionParticles.emitParticleAt(playerSprite.x, playerSprite.y);

            if (playerHealth <= 0) {
                this.gameOver(); // Trigger game over sequence
            }
        }

        /**
         * Handler for when a projectile hits an enemy.
         * @param {Phaser.GameObjects.Sprite} projectile - The projectile physics sprite.
         * @param {Phaser.GameObjects.Sprite} enemy - The enemy physics sprite.
         */
        hitEnemy(projectile, enemy) {
            // Deactivate both projectile and enemy
            projectile.disableBody(true, true);
            if (projectile.graphics) {
                projectile.graphics.clear(); // Clear projectile visual drawing
            }

            enemy.disableBody(true, true);
            if (enemy.graphics) {
                enemy.graphics.clear(); // Clear enemy visual drawing
            }

            score += 10; // Increase score
            scoreText.setText('Score: ' + score);

            // Emit explosion particles at the enemy's position
            explosionParticles.emitParticleAt(enemy.x, enemy.y);
        }

        /**
         * Handles the game over state: stops gameplay, shows messages, and prepares for restart.
         */
        gameOver() {
            isGameOver = true;
            this.physics.pause(); // Stop all physics movement and collisions

            // Hide player and clear its drawing
            player.setActive(false).setVisible(false);
            playerGraphics.clear();

            // Hide all active enemies and clear their drawings
            enemies.children.each(function(enemy) {
                enemy.disableBody(true, true);
                if (enemy.graphics) enemy.graphics.clear();
            });
            // Hide all active projectiles and clear their drawings
            projectiles.children.each(function(projectile) {
                projectile.disableBody(true, true);
                if (projectile.graphics) projectile.graphics.clear();
            });

            // Display game over messages
            gameOverText.setVisible(true);
            restartText.setVisible(true);
        }
    }

    // Initialize the Phaser game
    const game = new Phaser.Game(config);
    // Add and start the GameScene immediately
    game.scene.add('GameScene', GameScene, true);
</script>

</body>
</html>