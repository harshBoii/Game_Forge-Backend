<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Endless Racing - Dodge & Destroy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      height: 100%;
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .game-container {
      position: relative;
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 100%);
      border-radius: 12px;
      box-shadow:
        0 0 60px rgba(100, 200, 255, 0.3),
        inset 0 0 40px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    canvas {
      display: block;
      background: linear-gradient(180deg, #0f1419 0%, #050709 100%);
    }

    .ui-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #64c8ff;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }

    .ui-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ui-item {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.35);
      padding: 8px 12px;
      border-radius: 6px;
      border-left: 3px solid #64c8ff;
    }

    .ui-item span.value {
      font-weight: bold;
      color: #ffff66;
      min-width: 48px;
      display: inline-block;
      text-align: right;
    }

    .ui-item .bar {
      position: relative;
      width: 120px;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      overflow: hidden;
    }

    .ui-item .bar .fill {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, #64c8ff, #00ffa8);
      box-shadow: 0 0 10px rgba(0,255,168,0.6);
    }

    .controls {
      position: absolute;
      bottom: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      color: #9ad7ff;
      font-size: 12px;
      opacity: 0.9;
      pointer-events: none;
    }

    .controls .kbd {
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(100,200,255,0.35);
      padding: 3px 6px;
      border-radius: 4px;
      margin: 0 2px;
      color: #ccecff;
    }

    .banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.6);
      padding: 16px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8f6ff;
      text-align: center;
      z-index: 20;
      display: none;
    }

    .banner h1 {
      margin: 0 0 8px 0;
      font-size: 24px;
      color: #ffed75;
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }

    .banner p {
      margin: 4px 0;
      opacity: 0.9;
    }

    .tap-hint {
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(100,200,255,0.35);
      border-radius: 8px;
      color: #ccecff;
      padding: 8px 10px;
      font-size: 12px;
      z-index: 10;
      display: none;
    }

  </style>
</head>
<body>
  <div class="game-container" id="container">
    <canvas id="game"></canvas>

    <div class="ui-overlay" id="ui">
      <div class="ui-row">
        <div class="ui-item">Score: <span class="value" id="score">0</span></div>
        <div class="ui-item">Speed: <span class="value" id="speed">0</span> km/h</div>
        <div class="ui-item">Destroyed: <span class="value" id="kills">0</span></div>
      </div>
      <div class="ui-row">
        <div class="ui-item">
          Bullets: <span class="value" id="bullets">∞</span>
          <div class="bar" title="Gun Cooldown">
            <div class="fill" id="gunBar"></div>
          </div>
        </div>
        <div class="ui-item">
          Missiles: <span class="value" id="missiles">3</span>
          <div class="bar" title="Missile Cooldown">
            <div class="fill" id="missileBar"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="controls" id="controls">
      <div>
        Move <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> or <span class="kbd">Arrows</span>
      </div>
      <div>
        Shoot <span class="kbd">Space</span> • Missile <span class="kbd">M</span> • Restart <span class="kbd">R</span>
      </div>
    </div>

    <div class="banner" id="banner">
      <h1 id="bannerTitle">Game Over</h1>
      <p id="bannerSubtitle">Press R to restart</p>
    </div>

    <div class="tap-hint" id="tapHint">
      Tap left/right to steer. Tap top to shoot, bottom-right for missile.
    </div>
  </div>

  <script>
    (() => {
      const container = document.getElementById('container');
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const uiScore = document.getElementById('score');
      const uiSpeed = document.getElementById('speed');
      const uiKills = document.getElementById('kills');
      const uiMissiles = document.getElementById('missiles');
      const uiGunBar = document.getElementById('gunBar');
      const uiMissileBar = document.getElementById('missileBar');
      const banner = document.getElementById('banner');
      const bannerTitle = document.getElementById('bannerTitle');
      const tapHint = document.getElementById('tapHint');

      // Sizing
      function fit() {
        const maxW = Math.min(window.innerWidth - 20, 560);
        const maxH = Math.min(window.innerHeight - 20, 960);
        const aspect = 9/16; // portrait
        let w = maxW;
        let h = Math.round(w / aspect);
        if (h > maxH) {
          h = maxH;
          w = Math.round(h * aspect);
        }
        container.style.width = w + 'px';
        container.style.height = h + 'px';
        canvas.width = w * devicePixelRatio;
        canvas.height = h * devicePixelRatio;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

        ROAD.w = Math.floor(w * 0.72);
        ROAD.x = Math.floor((w - ROAD.w) / 2);
        ROAD.laneCount = 4;
        ROAD.laneW = Math.floor(ROAD.w / ROAD.laneCount);
        WORLD.w = w;
        WORLD.h = h;
      }

      // World/road
      const WORLD = { w: 360, h: 640 };
      const ROAD = { x: 40, w: 280, laneW: 70, laneCount: 4, scroll: 0 };

      // Input
      const keys = {};
      let lastShotAt = 0;
      let lastMissileAt = -9999;
      const GUN_COOLDOWN = 140; // ms
      const MISSILE_COOLDOWN = 1250; // ms

      // Player
      const player = {
        x: 0, y: 0, w: 42, h: 70,
        speed: 90, // km/h for UI; scroll speed derived
        vx: 0, vy: 0,
        color: '#5cffb9',
        alive: true,
      };

      // Game state
      let score = 0;
      let kills = 0;
      let missiles = 3;
      let time = 0;
      let gameOver = false;

      // Entities
      const cars = [];
      const bullets = [];
      const missilesArr = [];
      const explosions = [];
      const particles = [];

      // Spawning
      let spawnTimer = 0;
      let spawnInterval = 700;

      // Helpers
      function rand(a, b) { return Math.random() * (b - a) + a; }
      function choice(arr) { return arr[(Math.random() * arr.length) | 0]; }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function reset() {
        player.x = ROAD.x + ROAD.w / 2 - player.w / 2;
        player.y = WORLD.h - player.h - 24;
        player.vx = player.vy = 0;
        player.speed = 110;
        player.alive = true;

        bullets.length = 0;
        missilesArr.length = 0;
        cars.length = 0;
        explosions.length = 0;
        particles.length = 0;

        score = 0;
        kills = 0;
        missiles = 3;
        spawnTimer = 0;
        lastShotAt = 0;
        lastMissileAt = -9999;
        time = performance.now();
        gameOver = false;
        banner.style.display = 'none';
      }

      function laneCenter(i) {
        return ROAD.x + i * ROAD.laneW + ROAD.laneW / 2;
      }

      function spawnCar() {
        const lane = (Math.random() * ROAD.laneCount) | 0;
        const w = 44 + ((Math.random() * 2) | 0) * 10;
        const h = 78;
        const color = choice(['#ff5964', '#f5a623', '#14d3ff', '#9b59b6', '#00e676', '#e74c3c']);
        const speed = rand(0.8, 1.25); // relative
        // prevent overlapping spawn by checking last car in same lane
        const x = laneCenter(lane) - w / 2;
        const yStart = -h - 20;
        cars.push({ x, y: yStart, w, h, lane, color, speed, alive: true, hp: 1 });
      }

      function rectsOverlap(a, b) {
        return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
      }

      function circleRectOverlap(cx, cy, r, rect) {
        const nx = clamp(cx, rect.x, rect.x + rect.w);
        const ny = clamp(cy, rect.y, rect.y + rect.h);
        const dx = cx - nx;
        const dy = cy - ny;
        return dx * dx + dy * dy <= r * r;
      }

      function addExplosion(x, y, radius = 90) {
        explosions.push({ x, y, r: 8, maxR: radius, t: 0, ttl: 420, didDamage: false });
        // particles
        for (let i = 0; i < 22; i++) {
          const a = Math.random() * Math.PI * 2;
          const sp = rand(1, 4);
          particles.push({
            x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
            life: rand(300, 700), t: 0,
            color: i % 2 ? '#ffdd55' : '#ff7766', size: rand(2, 4)
          });
        }
      }

      // DRAW
      function drawRoad(dt) {
        // asphalt already via canvas bg
        // side borders
        ctx.fillStyle = '#1b2a35';
        ctx.fillRect(ROAD.x - 8, 0, 8, WORLD.h);
        ctx.fillRect(ROAD.x + ROAD.w, 0, 8, WORLD.h);

        // lane markers
        const dashH = 28;
        const gap = 22;
        ROAD.scroll += scrollSpeed() * dt * 0.08;
        const offsetY = -(ROAD.scroll % (dashH + gap));
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 3;
        ctx.setLineDash([dashH, gap]);
        ctx.lineDashOffset = offsetY;
        for (let i = 1; i < ROAD.laneCount; i++) {
          const x = ROAD.x + i * ROAD.laneW;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, WORLD.h);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      function drawCar(c) {
        const r = 6;
        ctx.fillStyle = c.color;
        roundRect(ctx, c.x, c.y, c.w, c.h, r);
        ctx.fill();
        // windshield
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        roundRect(ctx, c.x + 6, c.y + 10, c.w - 12, 16, 4);
        ctx.fill();
        // tail lights
        ctx.fillStyle = 'rgba(255, 70, 60, 0.8)';
        ctx.fillRect(c.x + 6, c.y + c.h - 6, 8, 3);
        ctx.fillRect(c.x + c.w - 14, c.y + c.h - 6, 8, 3);
      }

      function drawPlayer() {
        const p = player;
        const r = 8;
        ctx.fillStyle = p.color;
        roundRect(ctx, p.x, p.y, p.w, p.h, r);
        ctx.fill();
        // cockpit
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        roundRect(ctx, p.x + 6, p.y + 12, p.w - 12, 22, 6);
        ctx.fill();
        // neon glow
        ctx.shadowColor = '#00ffcc';
        ctx.shadowBlur = 18;
        ctx.strokeStyle = 'rgba(0,255,204,0.35)';
        ctx.lineWidth = 2;
        roundRect(ctx, p.x + 2, p.y + 2, p.w - 4, p.h - 4, 6);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      function drawBullet(b) {
        ctx.fillStyle = '#9ad7ff';
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x + m.w/2, m.y + m.h/2);
        ctx.rotate(m.a || 0);
        ctx.fillStyle = '#ffdd55';
        roundRect(ctx, -m.w/2, -m.h/2, m.w, m.h, 3);
        ctx.fill();
        // flame
        ctx.fillStyle = 'rgba(255, 120, 60, 0.9)';
        ctx.beginPath();
        ctx.moveTo(-m.w/2, 0);
        ctx.lineTo(-m.w/2 - 6, -3);
        ctx.lineTo(-m.w/2 - 6, 3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawExplosion(ex) {
        const alpha = 1 - ex.t / ex.ttl;
        const r = ex.r;
        // ring
        ctx.strokeStyle = `rgba(255, 220, 120, ${alpha})`;
        ctx.lineWidth = 6 * alpha;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, r, 0, Math.PI * 2);
        ctx.stroke();
        // inner
        const grd = ctx.createRadialGradient(ex.x, ex.y, 0, ex.x, ex.y, r);
        grd.addColorStop(0, `rgba(255, 210, 90, ${0.3 * alpha})`);
        grd.addColorStop(1, 'rgba(255, 210, 90, 0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.t += dt;
          p.x += p.vx;
          p.y += p.vy;
          const a = 1 - p.t / p.life;
          ctx.fillStyle = p.color.replace(')', `, ${Math.max(0, a)})`).replace('rgb', 'rgba');
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          if (p.t >= p.life) particles.splice(i, 1);
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      }

      // Mechanics
      function scrollSpeed() {
        // convert km/h to px per frame factor; tune multiplier
        return player.speed * 0.4; // px/s baseline
      }

      function shootBullet() {
        const now = performance.now();
        if (now - lastShotAt < GUN_COOLDOWN) return;
        if (!player.alive) return;
        lastShotAt = now;
        const bW = 4, bH = 14;
        bullets.push({
          x: player.x + player.w/2 - bW/2,
          y: player.y - 6,
          w: bW, h: bH,
          vy: -12,
        });
      }

      function fireMissile() {
        const now = performance.now();
        if (now - lastMissileAt < MISSILE_COOLDOWN) return;
        if (missiles <= 0 || !player.alive) return;
        lastMissileAt = now;
        missiles--;

        // target nearest car ahead
        let target = null;
        let bestDist = Infinity;
        for (const c of cars) {
          if (c.y + c.h < player.y) {
            const dx = (c.x + c.w/2) - (player.x + player.w/2);
            const dy = (c.y + c.h/2) - (player.y + player.h/2);
            const d2 = dx*dx + dy*dy;
            if (d2 < bestDist) { bestDist = d2; target = c; }
          }
        }
        const m = {
          x: player.x + player.w/2 - 6,
          y: player.y - 10,
          w: 12, h: 22,
          vx: 0, vy: -6,
          a: 0,
          target,
          turn: 0.08,
          speed: 6.5,
        };
        missilesArr.push(m);
      }

      // Mobile tap handling (simple zones)
      let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      let touchState = { left:false, right:false, up:false, down:false, shoot:false, missile:false };
      if (isMobile) {
        tapHint.style.display = 'block';
        container.addEventListener('touchstart', onTouch, { passive: false });
        container.addEventListener('touchmove', onTouch, { passive: false });
        container.addEventListener('touchend', onTouchEnd, { passive: false });
      }

      function onTouch(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        touchState = { left:false, right:false, up:false, down:false, shoot:false, missile:false };
        for (const t of e.touches) {
          const x = t.clientX - rect.left;
          const y = t.clientY - rect.top;
          if (y < rect.height * 0.35) {
            touchState.shoot = true;
          } else if (x < rect.width * 0.33) {
            touchState.left = true;
          } else if (x > rect.width * 0.66) {
            touchState.right = true;
          } else if (y > rect.height * 0.7 && x > rect.width * 0.55) {
            touchState.missile = true;
          }
        }
        if (touchState.shoot) shootBullet();
        if (touchState.missile) fireMissile();
      }

      function onTouchEnd(e) {
        e.preventDefault();
        touchState = { left:false, right:false, up:false, down:false, shoot:false, missile:false };
      }

      // Input keyboard
      window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.code === 'Space') { shootBullet(); e.preventDefault(); }
        if (e.key.toLowerCase() === 'm') { fireMissile(); }
        if (e.key.toLowerCase() === 'r' && gameOver) { reset(); }
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      // Main update
      function update(dt) {
        if (!player.alive) return;

        // speed control
        if (keys['w'] || keys['arrowup']) player.speed = clamp(player.speed + dt * 55, 80, 220);
        else if (keys['s'] || keys['arrowdown']) player.speed = clamp(player.speed - dt * 75, 60, 220);
        else player.speed = clamp(player.speed + (110 - player.speed) * 0.02, 60, 220);

        // move player
        const steer = (keys['a'] || keys['arrowleft'] || touchState.left ? -1 : 0) +
                      (keys['d'] || keys['arrowright'] || touchState.right ? 1 : 0);
        player.vx = steer * 4.2;
        player.x += player.vx * (dt / (1000/60)) * 3.2;
        player.x = clamp(player.x, ROAD.x + 4, ROAD.x + ROAD.w - player.w - 4);

        // spawning traffic
        spawnTimer -= dt;
        const density = clamp(1.0 + (score / 4000), 1, 2.2);
        if (spawnTimer <= 0) {
          spawnCar();
          spawnTimer = spawnInterval / density;
        }

        // move cars
        for (let i = cars.length - 1; i >= 0; i--) {
          const c = cars[i];
          c.y += (scrollSpeed() * 0.016 + c.speed * 1.4) * (dt / (1000/60));
          if (c.y > WORLD.h + 40) {
            cars.splice(i, 1);
            continue;
          }
          // collision with player
          if (rectsOverlap(player, c)) {
            player.alive = false;
            gameOver = true;
            bannerTitle.textContent = 'Crashed!';
            banner.style.display = 'block';
          }
        }

        // bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.y += b.vy * (dt / (1000/60)) * 12;
          if (b.y + b.h < -20) { bullets.splice(i, 1); continue; }

          for (let j = cars.length - 1; j >= 0; j--) {
            const c = cars[j];
            if (rectsOverlap(b, c)) {
              bullets.splice(i, 1);
              cars.splice(j, 1);
              kills++;
              score += 120;
              // small explosion particles
              addExplosion(c.x + c.w/2, c.y + c.h/2, 60);
              // small chance to drop missile
              if (Math.random() < 0.08) missiles = Math.min(missiles + 1, 6);
              break;
            }
          }
        }

        // missiles
        for (let i = missilesArr.length - 1; i >= 0; i--) {
          const m = missilesArr[i];
          // reacquire target if lost
          if (!m.target || !cars.includes(m.target) || (m.target.y + m.target.h) > (player.y + player.h)) {
            // find any ahead
            let t = null; let best = Infinity;
            for (const c of cars) {
              if (c.y + c.h < player.y) {
                const dx = (c.x + c.w/2) - (m.x + m.w/2);
                const dy = (c.y + c.h/2) - (m.y + m.h/2);
                const d2 = dx*dx + dy*dy;
                if (d2 < best) { best = d2; t = c; }
              }
            }
            m.target = t || null;
          }

          // steer towards target
          if (m.target) {
            const tx = m.target.x + m.target.w/2;
            const ty = m.target.y + m.target.h/2;
            const dx = tx - (m.x + m.w/2);
            const dy = ty - (m.y + m.h/2);
            const ang = Math.atan2(dy, dx);
            // turn current angle towards ang
            const cur = m.a || -Math.PI/2;
            let diff = ((ang - cur + Math.PI*3) % (Math.PI*2)) - Math.PI;
            m.a = cur + clamp(diff, -m.turn, m.turn);
            m.vx = Math.cos(m.a) * m.speed;
            m.vy = Math.sin(m.a) * m.speed;
          } else {
            m.a = -Math.PI/2;
            m.vx = 0;
            m.vy = -m.speed * 1.1;
          }

          m.x += m.vx * (dt / (1000/60)) * 6;
          m.y += m.vy * (dt / (1000/60)) * 6;

          // collision with cars or out of bounds
          let hit = false;
          for (let j = cars.length - 1; j >= 0; j--) {
            const c = cars[j];
            if (rectsOverlap({x:m.x, y:m.y, w:m.w, h:m.h}, c)) {
              hit = true;
              break;
            }
          }
          if (hit || m.y < -40 || m.x < -40 || m.x > WORLD.w + 40) {
            // explode
            addExplosion(m.x + m.w/2, m.y + m.h/2, 110);
            missilesArr.splice(i, 1);
          }
        }

        // explosions damage once on early growth
        for (let i = explosions.length - 1; i >= 0; i--) {
          const ex = explosions[i];
          ex.t += dt;
          const grow = Math.min(1, ex.t / 200);
          ex.r = ex.maxR * grow;
          if (!ex.didDamage && grow > 0.5) {
            ex.didDamage = true;
            // destroy cars within radius
            for (let j = cars.length - 1; j >= 0; j--) {
              const c = cars[j];
              if (circleRectOverlap(ex.x, ex.y, ex.r, c)) {
                cars.splice(j, 1);
                kills++;
                score += 180;
                // chain particles
                for (let k = 0; k < 8; k++) {
                  particles.push({
                    x: c.x + c.w/2, y: c.y + c.h/2,
                    vx: rand(-1.5, 1.5), vy: rand(-1.5, 1.5),
                    life: rand(250, 550), t: 0, color: '#ff9966', size: rand(1.5, 3.5)
                  });
                }
                if (Math.random() < 0.12) missiles = Math.min(missiles + 1, 6);
              }
            }
          }
          if (ex.t >= ex.ttl) explosions.splice(i, 1);
        }

        // score by distance
        score += dt * (player.speed / 32);
      }

      // Main loop
      function loop(now) {
        const dt = Math.min(50, now - time);
        time = now;

        ctx.clearRect(0, 0, WORLD.w, WORLD.h);

        drawRoad(dt);

        // update or stop if game over
        if (!gameOver) update(dt);

        // draw cars
        for (const c of cars) drawCar(c);

        // draw bullets
        for (const b of bullets) drawBullet(b);

        // draw missiles
        for (const m of missilesArr) drawMissile(m);

        // draw explosions
        for (const ex of explosions) drawExplosion(ex);

        // draw particles
        drawParticles(dt);

        // draw player last
        if (player.alive) drawPlayer();

        // UI update
        uiScore.textContent = Math.floor(score).toLocaleString();
        uiSpeed.textContent = Math.floor(player.speed);
        uiKills.textContent = kills;
        uiMissiles.textContent = missiles;

        // cooldown bars
        const nowMs = performance.now();
        const gunPct = clamp((nowMs - lastShotAt) / GUN_COOLDOWN, 0, 1) * 100;
        uiGunBar.style.width = gunPct + '%';
        const misPct = clamp((nowMs - lastMissileAt) / MISSILE_COOLDOWN, 0, 1) * 100;
        uiMissileBar.style.width = misPct + '%';

        requestAnimationFrame(loop);
      }

      // Gun auto fire on hold
      setInterval(() => {
        if (!player.alive) return;
        if (keys[' '] || keys['space']) shootBullet();
      }, 40);

      // Resize and start
      window.addEventListener('resize', fit);
      fit();
      reset();
      requestAnimationFrame((t) => { time = t; loop(t); });

      // Initial car seeding
      for (let i = 0; i < 5; i++) {
        spawnCar();
        cars[cars.length - 1].y = -i * 140 - 80;
      }
    })();
  </script>
</body>
</html>